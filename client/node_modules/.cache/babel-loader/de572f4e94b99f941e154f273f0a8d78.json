{"ast":null,"code":"import _toConsumableArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useMemo } from 'react';\nvar RENDER_BACTCH_SIZE = 8;\nexport function useViewportRows(_ref) {\n  var rawRows = _ref.rawRows,\n      rowHeight = _ref.rowHeight,\n      clientHeight = _ref.clientHeight,\n      scrollTop = _ref.scrollTop,\n      groupBy = _ref.groupBy,\n      rowGrouper = _ref.rowGrouper,\n      expandedGroupIds = _ref.expandedGroupIds;\n\n  var _useMemo = useMemo(function () {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    var groupRows = function groupRows(rows, _ref2, startRowIndex) {\n      var _ref3 = _toArray(_ref2),\n          groupByKey = _ref3[0],\n          remainingGroupByKeys = _ref3.slice(1);\n\n      var groupRowsCount = 0;\n      var groups = {};\n\n      for (var _i = 0, _Object$entries = Object.entries(rowGrouper(rows, groupByKey)); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            key = _Object$entries$_i[0],\n            childRows = _Object$entries$_i[1];\n\n        // Recursively group each parent group\n        var _ref4 = remainingGroupByKeys.length === 0 ? [childRows, childRows.length] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1),\n            _ref5 = _slicedToArray(_ref4, 2),\n            childGroups = _ref5[0],\n            childRowsCount = _ref5[1]; // 1 for parent row\n\n\n        groups[key] = {\n          childRows: childRows,\n          childGroups: childGroups,\n          startRowIndex: startRowIndex + groupRowsCount\n        };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]),\n      _useMemo2 = _slicedToArray(_useMemo, 2),\n      groupedRows = _useMemo2[0],\n      rowsCount = _useMemo2[1];\n\n  var _useMemo3 = useMemo(function () {\n    var allGroupRows = new Set();\n    if (!groupedRows) return [rawRows, allGroupRows];\n    var flattenedRows = [];\n\n    var expandGroup = function expandGroup(rows, parentId, level) {\n      if (Array.isArray(rows)) {\n        flattenedRows.push.apply(flattenedRows, _toConsumableArray(rows));\n        return;\n      }\n\n      Object.keys(rows).forEach(function (groupKey, posInSet, keys) {\n        var _a; // TODO: should users have control over the generated key?\n\n\n        var id = parentId !== undefined ? \"\".concat(parentId, \"__\").concat(groupKey) : groupKey;\n        var isExpanded = (_a = expandedGroupIds === null || expandedGroupIds === void 0 ? void 0 : expandedGroupIds.has(id)) !== null && _a !== void 0 ? _a : false;\n        var _rows$groupKey = rows[groupKey],\n            childRows = _rows$groupKey.childRows,\n            childGroups = _rows$groupKey.childGroups,\n            startRowIndex = _rows$groupKey.startRowIndex; // https://github.com/microsoft/TypeScript/issues/17002\n\n        var groupRow = {\n          id: id,\n          parentId: parentId,\n          groupKey: groupKey,\n          isExpanded: isExpanded,\n          childRows: childRows,\n          level: level,\n          posInSet: posInSet,\n          startRowIndex: startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]),\n      _useMemo4 = _slicedToArray(_useMemo3, 2),\n      rows = _useMemo4[0],\n      allGroupRows = _useMemo4[1];\n\n  var isGroupRow = function isGroupRow(row) {\n    return allGroupRows.has(row);\n  };\n\n  var overscanThreshold = 4;\n  var rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  var rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  var rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  var rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  return {\n    rowOverscanStartIdx: rowOverscanStartIdx,\n    rowOverscanEndIdx: rowOverscanEndIdx,\n    rows: rows,\n    rowsCount: rowsCount,\n    isGroupRow: isGroupRow\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
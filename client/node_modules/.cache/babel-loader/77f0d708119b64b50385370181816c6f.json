{"ast":null,"code":"var _classCallCheck = require(\"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Vector3 = require(\"./lib/vector3\");\n/**\n * Measure properties of STLs\n */\n\n\nvar STLMeasures =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * @param {number} density - density of material in cm^3\n   */\n  function STLMeasures(density) {\n    _classCallCheck(this, STLMeasures);\n\n    this.density = density;\n    this.volume = 0;\n    this.area = 0;\n    this.minx = Infinity;\n    this.maxx = -Infinity;\n    this.miny = Infinity;\n    this.maxy = -Infinity;\n    this.minz = Infinity;\n    this.maxz = -Infinity;\n    this.xCenter = 0;\n    this.yCenter = 0;\n    this.zCenter = 0;\n  }\n  /**\n   * calculation of the triangle volume\n   * source: http://stackoverflow.com/questions/6518404/how-do-i-calculate-the-volume-of-an-object-stored-in-stl-files\n   * @param triangle\n   * @returns {number}\n   * @private\n   */\n\n\n  _createClass(STLMeasures, [{\n    key: \"addTriangle\",\n\n    /**\n     * add triangle\n     * @param triangle\n     */\n    value: function addTriangle(triangle) {\n      var currentVolume = this.constructor._triangleVolume(triangle);\n\n      this.volume += currentVolume;\n      var ab = triangle[1].clone().sub(triangle[0]);\n      var ac = triangle[2].clone().sub(triangle[0]);\n      this.area += ab.clone().cross(ac).length() / 2;\n      var tminx = Math.min(triangle[0].x, triangle[1].x, triangle[2].x);\n      this.minx = tminx < this.minx ? tminx : this.minx;\n      var tmaxx = Math.max(triangle[0].x, triangle[1].x, triangle[2].x);\n      this.maxx = tmaxx > this.maxx ? tmaxx : this.maxx;\n      var tminy = Math.min(triangle[0].y, triangle[1].y, triangle[2].y);\n      this.miny = tminy < this.miny ? tminy : this.miny;\n      var tmaxy = Math.max(triangle[0].y, triangle[1].y, triangle[2].y);\n      this.maxy = tmaxy > this.maxy ? tmaxy : this.maxy;\n      var tminz = Math.min(triangle[0].z, triangle[1].z, triangle[2].z);\n      this.minz = tminz < this.minz ? tminz : this.minz;\n      var tmaxz = Math.max(triangle[0].z, triangle[1].z, triangle[2].z);\n      this.maxz = tmaxz > this.maxz ? tmaxz : this.maxz; // Center of Mass calculation\n      // adapted from c++ at: https://stackoverflow.com/a/2085502/6482703\n\n      this.xCenter += (triangle[0].x + triangle[1].x + triangle[2].x) / 4 * currentVolume;\n      this.yCenter += (triangle[0].y + triangle[1].y + triangle[2].y) / 4 * currentVolume;\n      this.zCenter += (triangle[0].z + triangle[1].z + triangle[2].z) / 4 * currentVolume;\n    }\n    /**\n     * calculates final measurements\n     * @returns {{volume: number, weight: number, boundingBox: number[], area: number, centerOfMass: number[]}}\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var volumeTotal = Math.abs(this.volume) / 1000;\n      this.xCenter /= this.volume;\n      this.yCenter /= this.volume;\n      this.zCenter /= this.volume;\n      return {\n        volume: volumeTotal,\n        // cubic cm\n        weight: volumeTotal * this.density,\n        // gm\n        boundingBox: [this.maxx - this.minx, this.maxy - this.miny, this.maxz - this.minz],\n        area: this.area,\n        centerOfMass: [this.xCenter, this.yCenter, this.zCenter]\n      };\n    }\n  }], [{\n    key: \"_triangleVolume\",\n    value: function _triangleVolume(triangle) {\n      var v321 = triangle[2].x * triangle[1].y * triangle[0].z,\n          v231 = triangle[1].x * triangle[2].y * triangle[0].z,\n          v312 = triangle[2].x * triangle[0].y * triangle[1].z,\n          v132 = triangle[0].x * triangle[2].y * triangle[1].z,\n          v213 = triangle[1].x * triangle[0].y * triangle[2].z,\n          v123 = triangle[0].x * triangle[1].y * triangle[2].z;\n      return 1.0 / 6.0 * (-v321 + v231 + v312 - v132 - v213 + v123);\n    }\n  }]);\n\n  return STLMeasures;\n}();\n/**\n * NodeStl\n * =======\n * > const stl = NodeStl(__dirname + '/myCool.stl');\n * > console.log(stl.volume + 'cm^3');\n * > console.log(stl.weight + 'gm');\n */\n\n\nvar NodeStl =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * @param {string|buffer} path\n   * @param {object} config\n   */\n  function NodeStl(path) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      density: 1.04\n    };\n\n    _classCallCheck(this, NodeStl);\n\n    var buffer;\n\n    if (Object.prototype.toString.call(path) === \"[object String]\") {\n      var fs = require(\"fs\"); // moved this as a step toward browser compatibility\n\n\n      buffer = fs.readFileSync(path);\n    } else {\n      buffer = path;\n    }\n\n    this._parse(buffer, config);\n  }\n  /**\n   * check if stl is binary vs ASCII\n   * (borrowed some code from here: https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/STLLoader.js)\n   * @param {buffer} buffer\n   * @returns {boolean}\n   */\n\n\n  _createClass(NodeStl, [{\n    key: \"_parse\",\n\n    /**\n     * parse buffer and assign measurements\n     * @param {buffer} buffer\n     * @param {object} config\n     */\n    value: function _parse(buffer, config) {\n      var measures;\n\n      if (this.constructor._isBinary(buffer)) {\n        measures = this.constructor._parseSTLBinary(buffer, config.density);\n      } else {\n        measures = this.constructor._parseSTLString(buffer.toString(), config.density);\n      }\n\n      Object.assign(this, measures);\n    }\n    /**\n     * parses an STL ASCII string\n     * @param {string} stl\n     * @param {number} density - density of material in cm^3\n     * @returns {{volume: number, weight: number, boundingBox: number[], area: number, centerOfMass: number[]}}\n     }\n     */\n\n  }], [{\n    key: \"_isBinary\",\n    value: function _isBinary(buffer) {\n      var MAX_ASCII_CHAR_CODE = 127;\n      var header_size = 84;\n      var str = buffer.toString();\n\n      if (buffer.length <= header_size) {\n        return false; // an empty binary STL must be at least 84 bytes\n      }\n\n      for (var i = 0, strLen = str.length; i < strLen; ++i) {\n        if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE) {\n          return true;\n        }\n      }\n\n      var expected_size, face_size, n_faces;\n      face_size = 50;\n      n_faces = buffer.readUInt32LE(80); // An ASCII STL data must begin with 'solid ' as the first six bytes.\n      // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n      // plentiful. There are also many binary STL that start with solid\n      // regardless of this standard, so we check if offset 80, the location of\n      // the number of triangles in a binary STL matches the expected file size.\n\n      expected_size = header_size + n_faces * face_size;\n      return buffer.length === expected_size;\n    }\n  }, {\n    key: \"_parseSTLString\",\n    value: function _parseSTLString(stl, density) {\n      // yes, this is the regular expression, matching the vertexes\n      // it was kind of tricky but it is fast and does the job\n      var vertexes = stl.match(/facet\\s+normal\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+outer\\s+loop\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+endloop\\s+endfacet/g);\n      var measures = new STLMeasures(density);\n      vertexes.forEach(function (vert) {\n        var triangle = new Array(3);\n        vert.match(/vertex\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s+([-+]?\\b(?:[0-9]*\\.)?[0-9]+(?:[eE][-+]?[0-9]+)?\\b)\\s/g).forEach(function (vertex, i) {\n          var vector = vertex.replace(\"vertex\", \"\").match(/[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?/g);\n          triangle[i] = new Vector3(vector[0], vector[1], vector[2]);\n        });\n        measures.addTriangle(triangle);\n      });\n      return measures.finalize();\n    }\n    /**\n     * parsing an STL Binary File\n     * (borrowed some code from here: https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/STLLoader.js)\n     * @param {buffer} buffer\n     * @param {number} density - density of material in cm^3\n     * @returns {{volume: number, weight: number, boundingBox: number[], area: number, centerOfMass: number[]}}\n      */\n\n  }, {\n    key: \"_parseSTLBinary\",\n    value: function _parseSTLBinary(buffer, density) {\n      var faces = buffer.readUInt32LE(80);\n      var dataOffset = 84;\n      var faceLength = 12 * 4 + 2;\n      var measures = new STLMeasures(density);\n\n      for (var face = 0; face < faces; face++) {\n        var start = dataOffset + face * faceLength;\n        var triangle = new Array(3);\n\n        for (var i = 1; i <= 3; i++) {\n          var vertexstart = start + i * 12;\n          triangle[i - 1] = new Vector3(buffer.readFloatLE(vertexstart, true), buffer.readFloatLE(vertexstart + 4, true), buffer.readFloatLE(vertexstart + 8, true));\n        }\n\n        measures.addTriangle(triangle);\n      }\n\n      return measures.finalize();\n    }\n  }]);\n\n  return NodeStl;\n}();\n\nmodule.exports = NodeStl;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import _slicedToArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useMemo } from 'react';\nimport { getColumnMetrics } from '../utils';\nimport { ValueFormatter } from '../formatters';\nexport function useViewportColumns(_ref) {\n  var rawColumns = _ref.rawColumns,\n      columnWidths = _ref.columnWidths,\n      viewportWidth = _ref.viewportWidth,\n      scrollLeft = _ref.scrollLeft,\n      defaultColumnOptions = _ref.defaultColumnOptions,\n      rawGroupBy = _ref.rawGroupBy,\n      rowGrouper = _ref.rowGrouper;\n\n  var _a, _b, _c, _d;\n\n  var minColumnWidth = (_a = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.minWidth) !== null && _a !== void 0 ? _a : 80;\n  var defaultFormatter = (_b = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.formatter) !== null && _b !== void 0 ? _b : ValueFormatter;\n  var defaultSortable = (_c = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.sortable) !== null && _c !== void 0 ? _c : false;\n  var defaultResizable = (_d = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.resizable) !== null && _d !== void 0 ? _d : false;\n\n  var _useMemo = useMemo(function () {\n    return getColumnMetrics({\n      rawColumns: rawColumns,\n      minColumnWidth: minColumnWidth,\n      viewportWidth: viewportWidth,\n      columnWidths: columnWidths,\n      defaultSortable: defaultSortable,\n      defaultResizable: defaultResizable,\n      defaultFormatter: defaultFormatter,\n      rawGroupBy: rowGrouper ? rawGroupBy : undefined\n    });\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, rowGrouper, viewportWidth]),\n      columns = _useMemo.columns,\n      lastFrozenColumnIndex = _useMemo.lastFrozenColumnIndex,\n      totalColumnWidth = _useMemo.totalColumnWidth,\n      totalFrozenColumnWidth = _useMemo.totalFrozenColumnWidth,\n      groupBy = _useMemo.groupBy;\n\n  var _useMemo2 = useMemo(function () {\n    // get the viewport's left side and right side positions for non-frozen columns\n    var viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    var viewportRight = scrollLeft + viewportWidth; // get first and last non-frozen column indexes\n\n    var lastColIdx = columns.length - 1;\n    var firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx); // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    } // get the first visible non-frozen column index\n\n\n    var colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n    while (colVisibleStartIdx < lastColIdx) {\n      var _columns$colVisibleSt = columns[colVisibleStartIdx],\n          left = _columns$colVisibleSt.left,\n          width = _columns$colVisibleSt.width; // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n\n      if (left + width > viewportLeft) {\n        break;\n      }\n\n      colVisibleStartIdx++;\n    } // get the last visible non-frozen column index\n\n\n    var colVisibleEndIdx = colVisibleStartIdx;\n\n    while (colVisibleEndIdx < lastColIdx) {\n      var _columns$colVisibleEn = columns[colVisibleEndIdx],\n          left = _columns$colVisibleEn.left,\n          width = _columns$colVisibleEn.width; // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n\n      if (left + width >= viewportRight) {\n        break;\n      }\n\n      colVisibleEndIdx++;\n    }\n\n    var colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    var colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]),\n      _useMemo3 = _slicedToArray(_useMemo2, 2),\n      colOverscanStartIdx = _useMemo3[0],\n      colOverscanEndIdx = _useMemo3[1];\n\n  var viewportColumns = useMemo(function () {\n    var viewportColumns = [];\n\n    for (var colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      var column = columns[colIdx];\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  return {\n    columns: columns,\n    viewportColumns: viewportColumns,\n    totalColumnWidth: totalColumnWidth,\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    totalFrozenColumnWidth: totalFrozenColumnWidth,\n    groupBy: groupBy\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
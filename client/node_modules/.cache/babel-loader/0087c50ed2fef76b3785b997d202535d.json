{"ast":null,"code":"import _objectSpread from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _defineProperty from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { forwardRef, useState, useRef, useLayoutEffect, useEffect, useImperativeHandle, useCallback, createElement } from 'react';\nimport clsx from 'clsx';\nimport { useGridDimensions, useViewportColumns, useViewportRows } from './hooks';\nimport EventBus from './EventBus';\nimport HeaderRow from './HeaderRow';\nimport FilterRow from './FilterRow';\nimport Row from './Row';\nimport GroupRowRenderer from './GroupRow';\nimport SummaryRow from './SummaryRow';\nimport { assertIsValidKey, getColumnScrollPosition, getNextSelectedCellPosition, isSelectedCellEditable, canExitGrid, isCtrlKeyHeldDown, isDefaultCellInput } from './utils';\n/**\r\n * Main API Component to render a data grid of rows and columns\r\n *\r\n * @example\r\n *\r\n * <DataGrid columns={columns} rows={rows} />\r\n*/\n\nfunction DataGrid(_ref, ref) {\n  var rawColumns = _ref.columns,\n      rawRows = _ref.rows,\n      summaryRows = _ref.summaryRows,\n      rowKey = _ref.rowKey,\n      onRowsUpdate = _ref.onRowsUpdate,\n      onRowsChange = _ref.onRowsChange,\n      _ref$rowHeight = _ref.rowHeight,\n      rowHeight = _ref$rowHeight === void 0 ? 35 : _ref$rowHeight,\n      _ref$headerRowHeight = _ref.headerRowHeight,\n      headerRowHeight = _ref$headerRowHeight === void 0 ? rowHeight : _ref$headerRowHeight,\n      _ref$headerFiltersHei = _ref.headerFiltersHeight,\n      headerFiltersHeight = _ref$headerFiltersHei === void 0 ? 45 : _ref$headerFiltersHei,\n      selectedRows = _ref.selectedRows,\n      onSelectedRowsChange = _ref.onSelectedRowsChange,\n      sortColumn = _ref.sortColumn,\n      sortDirection = _ref.sortDirection,\n      onSort = _ref.onSort,\n      filters = _ref.filters,\n      onFiltersChange = _ref.onFiltersChange,\n      defaultColumnOptions = _ref.defaultColumnOptions,\n      rawGroupBy = _ref.groupBy,\n      rowGrouper = _ref.rowGrouper,\n      expandedGroupIds = _ref.expandedGroupIds,\n      onExpandedGroupIdsChange = _ref.onExpandedGroupIdsChange,\n      _ref$rowRenderer = _ref.rowRenderer,\n      RowRenderer = _ref$rowRenderer === void 0 ? Row : _ref$rowRenderer,\n      emptyRowsRenderer = _ref.emptyRowsRenderer,\n      onRowClick = _ref.onRowClick,\n      onScroll = _ref.onScroll,\n      onColumnResize = _ref.onColumnResize,\n      onSelectedCellChange = _ref.onSelectedCellChange,\n      onCheckCellIsEditable = _ref.onCheckCellIsEditable,\n      _ref$enableFilters = _ref.enableFilters,\n      enableFilters = _ref$enableFilters === void 0 ? false : _ref$enableFilters,\n      _ref$enableCellCopyPa = _ref.enableCellCopyPaste,\n      enableCellCopyPaste = _ref$enableCellCopyPa === void 0 ? false : _ref$enableCellCopyPa,\n      _ref$enableCellDragAn = _ref.enableCellDragAndDrop,\n      enableCellDragAndDrop = _ref$enableCellDragAn === void 0 ? false : _ref$enableCellDragAn,\n      _ref$cellNavigationMo = _ref.cellNavigationMode,\n      cellNavigationMode = _ref$cellNavigationMo === void 0 ? 'NONE' : _ref$cellNavigationMo,\n      _ref$editorPortalTarg = _ref.editorPortalTarget,\n      editorPortalTarget = _ref$editorPortalTarg === void 0 ? document.body : _ref$editorPortalTarg,\n      className = _ref.className,\n      style = _ref.style,\n      rowClass = _ref.rowClass,\n      ariaLabel = _ref['aria-label'],\n      ariaLabelledBy = _ref['aria-labelledby'],\n      ariaDescribedBy = _ref['aria-describedby'];\n\n  var _a;\n  /**\r\n   * states\r\n   */\n\n\n  var _useState = useState(function () {\n    return new EventBus();\n  }),\n      _useState2 = _slicedToArray(_useState, 1),\n      eventBus = _useState2[0];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      scrollTop = _useState4[0],\n      setScrollTop = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      scrollLeft = _useState6[0],\n      setScrollLeft = _useState6[1];\n\n  var _useState7 = useState(function () {\n    return new Map();\n  }),\n      _useState8 = _slicedToArray(_useState7, 2),\n      columnWidths = _useState8[0],\n      setColumnWidths = _useState8[1];\n\n  var _useState9 = useState({\n    idx: -1,\n    rowIdx: -1,\n    mode: 'SELECT'\n  }),\n      _useState10 = _slicedToArray(_useState9, 2),\n      selectedPosition = _useState10[0],\n      setSelectedPosition = _useState10[1];\n\n  var _useState11 = useState(null),\n      _useState12 = _slicedToArray(_useState11, 2),\n      copiedPosition = _useState12[0],\n      setCopiedPosition = _useState12[1];\n\n  var _useState13 = useState(false),\n      _useState14 = _slicedToArray(_useState13, 2),\n      isDragging = _useState14[0],\n      setDragging = _useState14[1];\n\n  var _useState15 = useState(undefined),\n      _useState16 = _slicedToArray(_useState15, 2),\n      draggedOverRowIdx = _useState16[0],\n      setOverRowIdx = _useState16[1];\n\n  var setDraggedOverRowIdx = useCallback(function (rowIdx) {\n    setOverRowIdx(rowIdx);\n    latestDraggedOverRowIdx.current = rowIdx;\n  }, []);\n  /**\r\n   * refs\r\n   */\n\n  var focusSinkRef = useRef(null);\n  var prevSelectedPosition = useRef(selectedPosition);\n  var latestDraggedOverRowIdx = useRef(draggedOverRowIdx);\n  var lastSelectedRowIdx = useRef(-1);\n  var isCellFocusable = useRef(false);\n  /**\r\n   * computed values\r\n   */\n\n  var _useGridDimensions = useGridDimensions(),\n      _useGridDimensions2 = _slicedToArray(_useGridDimensions, 3),\n      gridRef = _useGridDimensions2[0],\n      gridWidth = _useGridDimensions2[1],\n      gridHeight = _useGridDimensions2[2];\n\n  var headerRowsCount = enableFilters ? 2 : 1;\n  var summaryRowsCount = (_a = summaryRows === null || summaryRows === void 0 ? void 0 : summaryRows.length) !== null && _a !== void 0 ? _a : 0;\n  var totalHeaderHeight = headerRowHeight + (enableFilters ? headerFiltersHeight : 0);\n  var clientHeight = gridHeight - totalHeaderHeight - summaryRowsCount * rowHeight;\n  var isSelectable = selectedRows !== undefined && onSelectedRowsChange !== undefined;\n\n  var _useViewportColumns = useViewportColumns({\n    rawColumns: rawColumns,\n    columnWidths: columnWidths,\n    scrollLeft: scrollLeft,\n    viewportWidth: gridWidth,\n    defaultColumnOptions: defaultColumnOptions,\n    rawGroupBy: rawGroupBy,\n    rowGrouper: rowGrouper\n  }),\n      columns = _useViewportColumns.columns,\n      viewportColumns = _useViewportColumns.viewportColumns,\n      totalColumnWidth = _useViewportColumns.totalColumnWidth,\n      lastFrozenColumnIndex = _useViewportColumns.lastFrozenColumnIndex,\n      totalFrozenColumnWidth = _useViewportColumns.totalFrozenColumnWidth,\n      groupBy = _useViewportColumns.groupBy;\n\n  var _useViewportRows = useViewportRows({\n    rawRows: rawRows,\n    groupBy: groupBy,\n    rowGrouper: rowGrouper,\n    rowHeight: rowHeight,\n    clientHeight: clientHeight,\n    scrollTop: scrollTop,\n    expandedGroupIds: expandedGroupIds\n  }),\n      rowOverscanStartIdx = _useViewportRows.rowOverscanStartIdx,\n      rowOverscanEndIdx = _useViewportRows.rowOverscanEndIdx,\n      rows = _useViewportRows.rows,\n      rowsCount = _useViewportRows.rowsCount,\n      isGroupRow = _useViewportRows.isGroupRow;\n\n  var hasGroups = groupBy.length > 0 && rowGrouper;\n  var minColIdx = hasGroups ? -1 : 0;\n\n  if (hasGroups) {\n    // Cell drag is not supported on a treegrid\n    enableCellDragAndDrop = false;\n  }\n  /**\r\n   * effects\r\n   */\n\n\n  useLayoutEffect(function () {\n    if (selectedPosition === prevSelectedPosition.current || selectedPosition.mode === 'EDIT' || !isCellWithinBounds(selectedPosition)) return;\n    prevSelectedPosition.current = selectedPosition;\n    scrollToCell(selectedPosition);\n\n    if (isCellFocusable.current) {\n      isCellFocusable.current = false;\n      return;\n    }\n\n    focusSinkRef.current.focus({\n      preventScroll: true\n    });\n  });\n  useEffect(function () {\n    if (!onSelectedRowsChange) return;\n\n    var handleRowSelectionChange = function handleRowSelectionChange(_ref2) {\n      var rowIdx = _ref2.rowIdx,\n          checked = _ref2.checked,\n          isShiftClick = _ref2.isShiftClick;\n      assertIsValidKey(rowKey);\n      var newSelectedRows = new Set(selectedRows);\n      var row = rows[rowIdx];\n\n      if (isGroupRow(row)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = row.childRows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var childRow = _step.value;\n\n            if (checked) {\n              newSelectedRows.add(childRow[rowKey]);\n            } else {\n              newSelectedRows.delete(childRow[rowKey]);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        onSelectedRowsChange(newSelectedRows);\n        return;\n      }\n\n      var rowId = row[rowKey];\n\n      if (checked) {\n        newSelectedRows.add(rowId);\n        var previousRowIdx = lastSelectedRowIdx.current;\n        lastSelectedRowIdx.current = rowIdx;\n\n        if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n          var step = Math.sign(rowIdx - previousRowIdx);\n\n          for (var i = previousRowIdx + step; i !== rowIdx; i += step) {\n            var _row = rows[i];\n            if (isGroupRow(_row)) continue;\n            newSelectedRows.add(_row[rowKey]);\n          }\n        }\n      } else {\n        newSelectedRows.delete(rowId);\n        lastSelectedRowIdx.current = -1;\n      }\n\n      onSelectedRowsChange(newSelectedRows);\n    };\n\n    return eventBus.subscribe('SelectRow', handleRowSelectionChange);\n  }, [eventBus, isGroupRow, onSelectedRowsChange, rowKey, rows, selectedRows]);\n  useEffect(function () {\n    return eventBus.subscribe('SelectCell', selectCell);\n  });\n  useEffect(function () {\n    if (!onExpandedGroupIdsChange) return;\n\n    var toggleGroup = function toggleGroup(expandedGroupId) {\n      var newExpandedGroupIds = new Set(expandedGroupIds);\n\n      if (newExpandedGroupIds.has(expandedGroupId)) {\n        newExpandedGroupIds.delete(expandedGroupId);\n      } else {\n        newExpandedGroupIds.add(expandedGroupId);\n      }\n\n      onExpandedGroupIdsChange(newExpandedGroupIds);\n    };\n\n    return eventBus.subscribe('ToggleGroup', toggleGroup);\n  }, [eventBus, expandedGroupIds, onExpandedGroupIdsChange]);\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToColumn: function scrollToColumn(idx) {\n        scrollToCell({\n          idx: idx\n        });\n      },\n      scrollToRow: function scrollToRow(rowIdx) {\n        var current = gridRef.current;\n        if (!current) return;\n        current.scrollTop = rowIdx * rowHeight;\n      },\n      selectCell: selectCell\n    };\n  });\n  /**\r\n   * event handlers\r\n   */\n\n  function handleKeyDown(event) {\n    var key = event.key;\n    var row = rows[selectedPosition.rowIdx];\n\n    if (enableCellCopyPaste && isCtrlKeyHeldDown(event) && isCellWithinBounds(selectedPosition) && !isGroupRow(row) && selectedPosition.idx !== -1) {\n      // key may be uppercase `C` or `V`\n      var lowerCaseKey = key.toLowerCase();\n\n      if (lowerCaseKey === 'c') {\n        handleCopy();\n        return;\n      }\n\n      if (lowerCaseKey === 'v') {\n        handlePaste();\n        return;\n      }\n    }\n\n    if (isCellWithinBounds(selectedPosition) && isGroupRow(row) && selectedPosition.idx === -1 && ( // Collapse the current group row if it is focused and is in expanded state\n    key === 'ArrowLeft' && row.isExpanded || // Expand the current group row if it is focused and is in collapsed state\n    key === 'ArrowRight' && !row.isExpanded)) {\n      event.preventDefault(); // Prevents scrolling\n\n      eventBus.dispatch('ToggleGroup', row.id);\n      return;\n    }\n\n    switch (event.key) {\n      case 'Escape':\n        setCopiedPosition(null);\n        closeEditor();\n        return;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n      case 'Tab':\n      case 'Home':\n      case 'End':\n      case 'PageUp':\n      case 'PageDown':\n        navigate(event);\n        break;\n\n      default:\n        handleCellInput(event);\n        break;\n    }\n  }\n\n  function handleFocus() {\n    isCellFocusable.current = true;\n  }\n\n  function handleScroll(event) {\n    var _event$currentTarget = event.currentTarget,\n        scrollTop = _event$currentTarget.scrollTop,\n        scrollLeft = _event$currentTarget.scrollLeft;\n    setScrollTop(scrollTop);\n    setScrollLeft(scrollLeft);\n    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);\n  }\n\n  var handleColumnResize = useCallback(function (column, width) {\n    var newColumnWidths = new Map(columnWidths);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n    onColumnResize === null || onColumnResize === void 0 ? void 0 : onColumnResize(column.idx, width);\n  }, [columnWidths, onColumnResize]);\n\n  function getRawRowIdx(rowIdx) {\n    return hasGroups ? rawRows.indexOf(rows[rowIdx]) : rowIdx;\n  }\n\n  function handleCommit(_ref3) {\n    var cellKey = _ref3.cellKey,\n        rowIdx = _ref3.rowIdx,\n        updated = _ref3.updated;\n    rowIdx = getRawRowIdx(rowIdx);\n    onRowsUpdate === null || onRowsUpdate === void 0 ? void 0 : onRowsUpdate({\n      cellKey: cellKey,\n      fromRow: rowIdx,\n      toRow: rowIdx,\n      updated: updated,\n      action: 'CELL_UPDATE'\n    });\n    closeEditor();\n  }\n\n  function commitEditor2Changes() {\n    var _a;\n\n    if (((_a = columns[selectedPosition.idx]) === null || _a === void 0 ? void 0 : _a.editor2) === undefined || selectedPosition.mode === 'SELECT' || selectedPosition.row === selectedPosition.originalRow) {\n      return;\n    }\n\n    var updatedRows = _toConsumableArray(rawRows);\n\n    updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = selectedPosition.row;\n    onRowsChange === null || onRowsChange === void 0 ? void 0 : onRowsChange(updatedRows);\n  }\n\n  function handleCopy() {\n    var idx = selectedPosition.idx,\n        rowIdx = selectedPosition.rowIdx;\n    var rawRowIdx = getRawRowIdx(rowIdx);\n    var value = rawRows[rawRowIdx][columns[idx].key];\n    setCopiedPosition({\n      idx: idx,\n      rowIdx: rowIdx,\n      value: value\n    });\n  }\n\n  function handlePaste() {\n    if (copiedPosition === null || !isCellEditable(selectedPosition) || copiedPosition.idx === selectedPosition.idx && copiedPosition.rowIdx === selectedPosition.rowIdx) {\n      return;\n    }\n\n    var fromRow = getRawRowIdx(copiedPosition.rowIdx);\n    var fromCellKey = columns[copiedPosition.idx].key;\n    var toRow = getRawRowIdx(selectedPosition.rowIdx);\n    var cellKey = columns[selectedPosition.idx].key;\n    onRowsUpdate === null || onRowsUpdate === void 0 ? void 0 : onRowsUpdate({\n      cellKey: cellKey,\n      fromRow: fromRow,\n      toRow: toRow,\n      updated: _defineProperty({}, cellKey, copiedPosition.value),\n      action: 'COPY_PASTE',\n      fromCellKey: fromCellKey\n    });\n  }\n\n  function handleCellInput(event) {\n    var _a, _b;\n\n    if (!isCellWithinBounds(selectedPosition)) return;\n    var row = rows[selectedPosition.rowIdx];\n    if (isGroupRow(row)) return;\n    var key = event.key;\n    var column = columns[selectedPosition.idx];\n\n    if (selectedPosition.mode === 'EDIT') {\n      if (key === 'Enter') {\n        // Custom editors can listen for the event and stop propagation to prevent commit\n        commitEditor2Changes();\n        closeEditor();\n      }\n\n      return;\n    }\n\n    (_b = (_a = column.editorOptions) === null || _a === void 0 ? void 0 : _a.onCellKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n    if (event.isDefaultPrevented()) return;\n\n    if (isCellEditable(selectedPosition) && isDefaultCellInput(event)) {\n      setSelectedPosition(function (_ref4) {\n        var idx = _ref4.idx,\n            rowIdx = _ref4.rowIdx;\n        return {\n          idx: idx,\n          rowIdx: rowIdx,\n          key: key,\n          mode: 'EDIT',\n          row: row,\n          originalRow: row\n        };\n      });\n    }\n  }\n\n  function handleDragEnd() {\n    if (latestDraggedOverRowIdx.current === undefined) return;\n    var idx = selectedPosition.idx,\n        rowIdx = selectedPosition.rowIdx;\n    var column = columns[idx];\n    var cellKey = column.key;\n    var value = rawRows[rowIdx][cellKey];\n    onRowsUpdate === null || onRowsUpdate === void 0 ? void 0 : onRowsUpdate({\n      cellKey: cellKey,\n      fromRow: rowIdx,\n      toRow: latestDraggedOverRowIdx.current,\n      updated: _defineProperty({}, cellKey, value),\n      action: 'CELL_DRAG'\n    });\n    setDraggedOverRowIdx(undefined);\n  }\n\n  function handleMouseDown(event) {\n    if (event.buttons !== 1) return;\n    setDragging(true);\n    window.addEventListener('mouseover', onMouseOver);\n    window.addEventListener('mouseup', onMouseUp);\n\n    function onMouseOver(event) {\n      // Trigger onMouseup in edge cases where we release the mouse button but `mouseup` isn't triggered,\n      // for example when releasing the mouse button outside the iframe the grid is rendered in.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n      if (event.buttons !== 1) onMouseUp();\n    }\n\n    function onMouseUp() {\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mouseup', onMouseUp);\n      setDragging(false);\n      handleDragEnd();\n    }\n  }\n\n  function handleDoubleClick(event) {\n    event.stopPropagation();\n    var column = columns[selectedPosition.idx];\n    var cellKey = column.key;\n    var value = rawRows[selectedPosition.rowIdx][cellKey];\n    onRowsUpdate === null || onRowsUpdate === void 0 ? void 0 : onRowsUpdate({\n      cellKey: cellKey,\n      fromRow: selectedPosition.rowIdx,\n      toRow: rawRows.length - 1,\n      updated: _defineProperty({}, cellKey, value),\n      action: 'COLUMN_FILL'\n    });\n  }\n\n  function handleRowChange(row, commitChanges) {\n    if (selectedPosition.mode === 'SELECT') return;\n\n    if (commitChanges) {\n      var updatedRows = _toConsumableArray(rawRows);\n\n      updatedRows[getRawRowIdx(selectedPosition.rowIdx)] = row;\n      onRowsChange === null || onRowsChange === void 0 ? void 0 : onRowsChange(updatedRows);\n      closeEditor();\n    } else {\n      setSelectedPosition(function (position) {\n        return _objectSpread({}, position, {\n          row: row\n        });\n      });\n    }\n  }\n\n  function handleOnClose(commitChanges) {\n    if (commitChanges) {\n      commitEditor2Changes();\n    }\n\n    closeEditor();\n  }\n  /**\r\n   * utils\r\n   */\n\n\n  function isCellWithinBounds(_ref5) {\n    var idx = _ref5.idx,\n        rowIdx = _ref5.rowIdx;\n    return rowIdx >= 0 && rowIdx < rows.length && idx >= minColIdx && idx < columns.length;\n  }\n\n  function isCellEditable(position) {\n    return isCellWithinBounds(position) && isSelectedCellEditable({\n      columns: columns,\n      rows: rows,\n      selectedPosition: position,\n      onCheckCellIsEditable: onCheckCellIsEditable,\n      isGroupRow: isGroupRow\n    });\n  }\n\n  function selectCell(position) {\n    var enableEditor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!isCellWithinBounds(position)) return;\n    commitEditor2Changes();\n\n    if (enableEditor && isCellEditable(position)) {\n      var row = rows[position.rowIdx];\n      setSelectedPosition(_objectSpread({}, position, {\n        mode: 'EDIT',\n        key: null,\n        row: row,\n        originalRow: row\n      }));\n    } else {\n      setSelectedPosition(_objectSpread({}, position, {\n        mode: 'SELECT'\n      }));\n    }\n\n    onSelectedCellChange === null || onSelectedCellChange === void 0 ? void 0 : onSelectedCellChange(_objectSpread({}, position));\n  }\n\n  function closeEditor() {\n    if (selectedPosition.mode === 'SELECT') return;\n    setSelectedPosition(function (_ref6) {\n      var idx = _ref6.idx,\n          rowIdx = _ref6.rowIdx;\n      return {\n        idx: idx,\n        rowIdx: rowIdx,\n        mode: 'SELECT'\n      };\n    });\n  }\n\n  function scrollToCell(_ref7) {\n    var idx = _ref7.idx,\n        rowIdx = _ref7.rowIdx;\n    var current = gridRef.current;\n    if (!current) return;\n\n    if (typeof idx === 'number' && idx > lastFrozenColumnIndex) {\n      var clientWidth = current.clientWidth;\n      var _columns$idx = columns[idx],\n          left = _columns$idx.left,\n          width = _columns$idx.width;\n      var isCellAtLeftBoundary = left < scrollLeft + width + totalFrozenColumnWidth;\n      var isCellAtRightBoundary = left + width > clientWidth + scrollLeft;\n\n      if (isCellAtLeftBoundary || isCellAtRightBoundary) {\n        var newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    }\n\n    if (typeof rowIdx === 'number') {\n      if (rowIdx * rowHeight < scrollTop) {\n        // at top boundary, scroll to the row's top\n        current.scrollTop = rowIdx * rowHeight;\n      } else if ((rowIdx + 1) * rowHeight > scrollTop + clientHeight) {\n        // at bottom boundary, scroll the next row's top to the bottom of the viewport\n        current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n      }\n    }\n  }\n\n  function getNextPosition(key, ctrlKey, shiftKey) {\n    var idx = selectedPosition.idx,\n        rowIdx = selectedPosition.rowIdx;\n    var row = rows[rowIdx];\n    var isRowSelected = isCellWithinBounds(selectedPosition) && idx === -1; // If a group row is focused, and it is collapsed, move to the parent group row (if there is one).\n\n    if (key === 'ArrowLeft' && isRowSelected && isGroupRow(row) && !row.isExpanded && row.level !== 0) {\n      var parentRowIdx = -1;\n\n      for (var i = selectedPosition.rowIdx - 1; i >= 0; i--) {\n        var parentRow = rows[i];\n\n        if (isGroupRow(parentRow) && parentRow.id === row.parentId) {\n          parentRowIdx = i;\n          break;\n        }\n      }\n\n      if (parentRowIdx !== -1) {\n        return {\n          idx: idx,\n          rowIdx: parentRowIdx\n        };\n      }\n    }\n\n    switch (key) {\n      case 'ArrowUp':\n        return {\n          idx: idx,\n          rowIdx: rowIdx - 1\n        };\n\n      case 'ArrowDown':\n        return {\n          idx: idx,\n          rowIdx: rowIdx + 1\n        };\n\n      case 'ArrowLeft':\n        return {\n          idx: idx - 1,\n          rowIdx: rowIdx\n        };\n\n      case 'ArrowRight':\n        return {\n          idx: idx + 1,\n          rowIdx: rowIdx\n        };\n\n      case 'Tab':\n        if (selectedPosition.idx === -1 && selectedPosition.rowIdx === -1) {\n          return shiftKey ? {\n            idx: columns.length - 1,\n            rowIdx: rows.length - 1\n          } : {\n            idx: 0,\n            rowIdx: 0\n          };\n        }\n\n        return {\n          idx: idx + (shiftKey ? -1 : 1),\n          rowIdx: rowIdx\n        };\n\n      case 'Home':\n        // If row is selected then move focus to the first row\n        if (isRowSelected) return {\n          idx: idx,\n          rowIdx: 0\n        };\n        return ctrlKey ? {\n          idx: 0,\n          rowIdx: 0\n        } : {\n          idx: 0,\n          rowIdx: rowIdx\n        };\n\n      case 'End':\n        // If row is selected then move focus to the last row.\n        if (isRowSelected) return {\n          idx: idx,\n          rowIdx: rows.length - 1\n        };\n        return ctrlKey ? {\n          idx: columns.length - 1,\n          rowIdx: rows.length - 1\n        } : {\n          idx: columns.length - 1,\n          rowIdx: rowIdx\n        };\n\n      case 'PageUp':\n        return {\n          idx: idx,\n          rowIdx: rowIdx - Math.floor(clientHeight / rowHeight)\n        };\n\n      case 'PageDown':\n        return {\n          idx: idx,\n          rowIdx: rowIdx + Math.floor(clientHeight / rowHeight)\n        };\n\n      default:\n        return selectedPosition;\n    }\n  }\n\n  function navigate(event) {\n    var key = event.key,\n        shiftKey = event.shiftKey;\n    var ctrlKey = isCtrlKeyHeldDown(event);\n    var nextPosition = getNextPosition(key, ctrlKey, shiftKey);\n    var mode = cellNavigationMode;\n\n    if (key === 'Tab') {\n      // If we are in a position to leave the grid, stop editing but stay in that cell\n      if (canExitGrid({\n        shiftKey: shiftKey,\n        cellNavigationMode: cellNavigationMode,\n        columns: columns,\n        rowsCount: rows.length,\n        selectedPosition: selectedPosition\n      })) {\n        // Allow focus to leave the grid so the next control in the tab order can be focused\n        return;\n      }\n\n      mode = cellNavigationMode === 'NONE' ? 'CHANGE_ROW' : cellNavigationMode;\n    } // Do not allow focus to leave\n\n\n    event.preventDefault();\n    nextPosition = getNextSelectedCellPosition({\n      columns: columns,\n      rowsCount: rows.length,\n      cellNavigationMode: mode,\n      nextPosition: nextPosition\n    });\n    selectCell(nextPosition);\n  }\n\n  function getDraggedOverCellIdx(currentRowIdx) {\n    if (draggedOverRowIdx === undefined) return;\n    var rowIdx = selectedPosition.rowIdx;\n    var isDraggedOver = rowIdx < draggedOverRowIdx ? rowIdx < currentRowIdx && currentRowIdx <= draggedOverRowIdx : rowIdx > currentRowIdx && currentRowIdx >= draggedOverRowIdx;\n    return isDraggedOver ? selectedPosition.idx : undefined;\n  }\n\n  function getSelectedCellProps(rowIdx) {\n    if (selectedPosition.rowIdx !== rowIdx) return;\n\n    if (selectedPosition.mode === 'EDIT') {\n      return {\n        mode: 'EDIT',\n        idx: selectedPosition.idx,\n        onKeyDown: handleKeyDown,\n        editorPortalTarget: editorPortalTarget,\n        editorContainerProps: {\n          rowHeight: rowHeight,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          firstEditorKeyPress: selectedPosition.key,\n          onCommit: handleCommit,\n          onCommitCancel: closeEditor\n        },\n        editor2Props: {\n          rowHeight: rowHeight,\n          row: selectedPosition.row,\n          onRowChange: handleRowChange,\n          onClose: handleOnClose\n        }\n      };\n    }\n\n    return {\n      mode: 'SELECT',\n      idx: selectedPosition.idx,\n      onFocus: handleFocus,\n      onKeyDown: handleKeyDown,\n      dragHandleProps: enableCellDragAndDrop && isCellEditable(selectedPosition) ? {\n        onMouseDown: handleMouseDown,\n        onDoubleClick: handleDoubleClick\n      } : undefined\n    };\n  }\n\n  function getViewportRows() {\n    var _a;\n\n    var rowElements = [];\n    var startRowIndex = 0;\n\n    for (var rowIdx = rowOverscanStartIdx; rowIdx <= rowOverscanEndIdx; rowIdx++) {\n      var row = rows[rowIdx];\n      var top = rowIdx * rowHeight + totalHeaderHeight;\n\n      if (isGroupRow(row)) {\n        startRowIndex = row.startRowIndex;\n        rowElements.push(React.createElement(GroupRowRenderer, {\n          \"aria-level\": row.level + 1,\n          \"aria-setsize\": row.setSize,\n          \"aria-posinset\": row.posInSet + 1,\n          \"aria-rowindex\": headerRowsCount + startRowIndex + 1,\n          key: row.id,\n          id: row.id,\n          groupKey: row.groupKey,\n          viewportColumns: viewportColumns,\n          childRows: row.childRows,\n          rowIdx: rowIdx,\n          top: top,\n          level: row.level,\n          isExpanded: row.isExpanded,\n          selectedCellIdx: selectedPosition.rowIdx === rowIdx ? selectedPosition.idx : undefined,\n          isRowSelected: isSelectable && row.childRows.every(function (cr) {\n            return selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(cr[rowKey]);\n          }),\n          eventBus: eventBus,\n          onFocus: selectedPosition.rowIdx === rowIdx ? handleFocus : undefined,\n          onKeyDown: selectedPosition.rowIdx === rowIdx ? handleKeyDown : undefined\n        }));\n        continue;\n      }\n\n      startRowIndex++;\n      var key = hasGroups ? startRowIndex : rowIdx;\n      var isRowSelected = false;\n\n      if (rowKey !== undefined) {\n        var rowId = row[rowKey];\n        isRowSelected = (_a = selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.has(rowId)) !== null && _a !== void 0 ? _a : false;\n\n        if (typeof rowId === 'string' || typeof rowId === 'number') {\n          key = rowId;\n        }\n      }\n\n      rowElements.push(React.createElement(RowRenderer, {\n        \"aria-rowindex\": headerRowsCount + (hasGroups ? startRowIndex : rowIdx) + 1,\n        \"aria-selected\": isSelectable ? isRowSelected : undefined,\n        key: key,\n        rowIdx: rowIdx,\n        row: row,\n        viewportColumns: viewportColumns,\n        eventBus: eventBus,\n        isRowSelected: isRowSelected,\n        onRowClick: onRowClick,\n        rowClass: rowClass,\n        top: top,\n        copiedCellIdx: (copiedPosition === null || copiedPosition === void 0 ? void 0 : copiedPosition.rowIdx) === rowIdx ? copiedPosition.idx : undefined,\n        draggedOverCellIdx: getDraggedOverCellIdx(rowIdx),\n        setDraggedOverRowIdx: isDragging ? setDraggedOverRowIdx : undefined,\n        selectedCellProps: getSelectedCellProps(rowIdx)\n      }));\n    }\n\n    return rowElements;\n  } // Reset the positions if the current values are no longer valid. This can happen if a column or row is removed\n\n\n  if (selectedPosition.idx >= columns.length || selectedPosition.rowIdx >= rows.length) {\n    setSelectedPosition({\n      idx: -1,\n      rowIdx: -1,\n      mode: 'SELECT'\n    });\n    setCopiedPosition(null);\n    setDraggedOverRowIdx(undefined);\n  }\n\n  if (selectedPosition.mode === 'EDIT' && rows[selectedPosition.rowIdx] !== selectedPosition.originalRow) {\n    // Discard changes if rows are updated from outside\n    closeEditor();\n  }\n\n  return React.createElement(\"div\", {\n    role: hasGroups ? 'treegrid' : 'grid',\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-multiselectable\": isSelectable ? true : undefined,\n    \"aria-colcount\": columns.length,\n    \"aria-rowcount\": headerRowsCount + rowsCount + summaryRowsCount,\n    className: clsx('rdg', {\n      'rdg-viewport-dragging': isDragging\n    }, className),\n    style: _objectSpread({}, style, {\n      '--header-row-height': \"\".concat(headerRowHeight, \"px\"),\n      '--filter-row-height': \"\".concat(headerFiltersHeight, \"px\"),\n      '--row-width': \"\".concat(totalColumnWidth, \"px\"),\n      '--row-height': \"\".concat(rowHeight, \"px\")\n    }),\n    ref: gridRef,\n    onScroll: handleScroll\n  }, React.createElement(HeaderRow, {\n    rowKey: rowKey,\n    rows: rawRows,\n    columns: viewportColumns,\n    onColumnResize: handleColumnResize,\n    allRowsSelected: (selectedRows === null || selectedRows === void 0 ? void 0 : selectedRows.size) === rawRows.length,\n    onSelectedRowsChange: onSelectedRowsChange,\n    sortColumn: sortColumn,\n    sortDirection: sortDirection,\n    onSort: onSort\n  }), enableFilters && React.createElement(FilterRow, {\n    columns: viewportColumns,\n    filters: filters,\n    onFiltersChange: onFiltersChange\n  }), rows.length === 0 && emptyRowsRenderer ? createElement(emptyRowsRenderer) : React.createElement(React.Fragment, null, React.createElement(\"div\", {\n    ref: focusSinkRef,\n    tabIndex: 0,\n    className: \"rdg-focus-sink\",\n    onKeyDown: handleKeyDown\n  }), React.createElement(\"div\", {\n    style: {\n      height: Math.max(rows.length * rowHeight, clientHeight)\n    }\n  }), getViewportRows(), summaryRows === null || summaryRows === void 0 ? void 0 : summaryRows.map(function (row, rowIdx) {\n    return React.createElement(SummaryRow, {\n      \"aria-rowindex\": headerRowsCount + rowsCount + rowIdx + 1,\n      key: rowIdx,\n      rowIdx: rowIdx,\n      row: row,\n      bottom: rowHeight * (summaryRows.length - 1 - rowIdx),\n      viewportColumns: viewportColumns\n    });\n  })));\n}\n\nexport default forwardRef(DataGrid);","map":null,"metadata":{},"sourceType":"module"}
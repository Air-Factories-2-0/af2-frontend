{"ast":null,"code":"import { useRef, useEffect } from 'react';\n/**\r\n * Detecting outside click on a react component is surprisingly hard.\r\n * A general approach is to have a global click handler on the document\r\n * which checks if the click target is inside the editor container or\r\n * not using editorContainer.contains(e.target). This approach works well\r\n * until portals are used for editors. Portals render children into a DOM\r\n * node that exists outside the DOM hierarchy of the parent component so\r\n * editorContainer.contains(e.target) does not work. Here are some examples\r\n * of the DOM structure with different types of editors\r\n *\r\n *\r\n * SimpleEditor for example Texbox (No Portals)\r\n *   <div data-grid>..</div>\r\n *   <div portal-created-by-the-grid-for-editors>\r\n *      <div editor-container>\r\n *        <div simple-editor>..</div>\r\n *      </div>\r\n *   </div>\r\n *\r\n * ComplexEditor for example Modals (using Portals)\r\n *   <div data-grid>..</div>\r\n *   <div portal-created-by-the-grid-for-editors>\r\n *      <div editor-container>\r\n *        // Nothing here\r\n *      </div>\r\n *   </div>\r\n *   <div portal-created-by-the-editor>\r\n *     <div complex-editor>..</div>\r\n *   </div>\r\n *\r\n *\r\n * One approach to detect outside click is to use synthetic event bubbling through\r\n * portals. An event fired from inside a portal will propagate to ancestors\r\n * in the containing React tree, even if those elements are not ancestors\r\n * in the DOM tree. This means a click handler can be attached on the window\r\n * and on the editor container. The editor container can set a flag to notify\r\n * that the click was inside the editor and the window click handler can use\r\n * this flag to call onClickOutside. This approach however has a few caveats\r\n * - Click handler on the window is set using window.addEventListener\r\n * - Click handler on the editor container is set using onClick prop\r\n *\r\n * This means if a child component inside the editor calls e.stopPropagation\r\n * then the click handler on the editor container will not be called whereas\r\n * the document click handler will be called.\r\n * https://github.com/facebook/react/issues/12518\r\n *\r\n * To solve this issue onClickCapture event is used.\r\n */\n\nexport function useClickOutside(onClick) {\n  var clickedInsideRef = useRef(false); // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `handleDocumentClick` might otherwise miss valid click events.\n  // To that end we instead access the latest `onClick` prop via a ref.\n\n  var onClickRef = useRef(function () {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  useEffect(function () {\n    onClickRef.current = onClick;\n  });\n  useEffect(function () {\n    var animationFrameRequest;\n\n    function cancelAnimationFrameRequest() {\n      if (typeof animationFrameRequest === 'number') {\n        cancelAnimationFrame(animationFrameRequest);\n        animationFrameRequest = undefined;\n      }\n    }\n\n    function checkOutsideClick() {\n      animationFrameRequest = undefined;\n\n      if (clickedInsideRef.current) {\n        clickedInsideRef.current = false;\n      } else {\n        onClickRef.current();\n      }\n    }\n\n    function handleWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      clickedInsideRef.current = false;\n      animationFrameRequest = requestAnimationFrame(checkOutsideClick);\n    }\n\n    window.addEventListener('click', handleWindowCaptureClick, {\n      capture: true\n    });\n    return function () {\n      window.removeEventListener('click', handleWindowCaptureClick, {\n        capture: true\n      });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n  return function onClickCapture() {\n    clickedInsideRef.current = true;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _objectSpread from \"/home/costantinos/Documenti/Dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\nexport function getColumnMetrics(metrics) {\n  var left = 0;\n  var totalWidth = 0;\n  var allocatedWidths = 0;\n  var unassignedColumnsCount = 0;\n  var lastFrozenColumnIndex = -1;\n  var totalFrozenColumnWidth = 0;\n  var rawGroupBy = metrics.rawGroupBy;\n  var columns = metrics.rawColumns.map(function (metricsColumn) {\n    var width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    var column = _objectSpread({}, metricsColumn, {\n      width: width\n    });\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(column.key)) {\n      column.frozen = true;\n      column.rowGroup = true;\n    }\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n    }\n\n    return column;\n  });\n  columns.sort(function (_ref, _ref2) {\n    var aKey = _ref.key,\n        frozenA = _ref.frozen;\n    var bKey = _ref2.key,\n        frozenB = _ref2.frozen;\n    // Sort select column first:\n    if (aKey === SELECT_COLUMN_KEY) return -1;\n    if (bKey === SELECT_COLUMN_KEY) return 1; // Sort grouped columns second, following the groupBy order:\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(aKey)) {\n      if (rawGroupBy.includes(bKey)) {\n        return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n      }\n\n      return -1;\n    }\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(bKey)) return 1; // Sort frozen columns third:\n\n    if (frozenA) {\n      if (frozenB) return 0;\n      return -1;\n    }\n\n    if (frozenB) return 1; // Sort other columns last:\n\n    return 0;\n  });\n  var unallocatedWidth = metrics.viewportWidth - allocatedWidths;\n  var unallocatedColumnWidth = Math.max(Math.floor(unallocatedWidth / unassignedColumnsCount), metrics.minColumnWidth); // Filter rawGroupBy and ignore keys that do not match the columns prop\n\n  var groupBy = [];\n  var calculatedColumns = columns.map(function (column, idx) {\n    var _a, _b, _c, _d, _e; // Every column should have a valid width as this stage\n\n\n    var width = (_a = column.width) !== null && _a !== void 0 ? _a : clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n\n    var newColumn = _objectSpread({}, column, {\n      idx: idx,\n      width: width,\n      left: left,\n      sortable: (_b = column.sortable) !== null && _b !== void 0 ? _b : metrics.defaultSortable,\n      resizable: (_c = column.resizable) !== null && _c !== void 0 ? _c : metrics.defaultResizable,\n      formatter: (_d = column.formatter) !== null && _d !== void 0 ? _d : metrics.defaultFormatter\n    });\n\n    if (newColumn.rowGroup) {\n      groupBy.push(column.key);\n      newColumn.groupFormatter = (_e = column.groupFormatter) !== null && _e !== void 0 ? _e : ToggleGroupFormatter;\n    }\n\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  if (lastFrozenColumnIndex !== -1) {\n    var lastFrozenColumn = calculatedColumns[lastFrozenColumnIndex];\n    lastFrozenColumn.isLastFrozenColumn = true;\n    totalFrozenColumnWidth = lastFrozenColumn.left + lastFrozenColumn.width;\n  }\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    totalFrozenColumnWidth: totalFrozenColumnWidth,\n    totalColumnWidth: totalWidth,\n    groupBy: groupBy\n  };\n}\n\nfunction getSpecifiedWidth(_ref3, columnWidths, viewportWidth) {\n  var key = _ref3.key,\n      width = _ref3.width;\n\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, _ref4, minColumnWidth) {\n  var minWidth = _ref4.minWidth,\n      maxWidth = _ref4.maxWidth;\n  width = Math.max(width, minWidth !== null && minWidth !== void 0 ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n} // Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\n\n\nexport function canEdit(column, row) {\n  var _a, _b;\n\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n\n  return Boolean((_b = (_a = column.editor) !== null && _a !== void 0 ? _a : column.editor2) !== null && _b !== void 0 ? _b : column.editable);\n}\nexport function getColumnScrollPosition(columns, idx, currentScrollLeft, currentClientWidth) {\n  var left = 0;\n  var frozen = 0;\n\n  for (var i = 0; i < idx; i++) {\n    var column = columns[i];\n\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  var selectedColumn = columns[idx];\n\n  if (selectedColumn) {\n    var scrollLeft = left - frozen - currentScrollLeft;\n    var scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"module"}
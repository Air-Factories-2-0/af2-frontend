{"ast":null,"code":"var fsm = require('stream-fsm');\n\nvar split = require('split');\n\nvar normalize = require('triangle-normal');\n\nfunction trim(a) {\n  var nullTerm = a.indexOf(\"\\0\");\n\n  if (nullTerm > -1) {\n    a = a.substr(0, nullTerm);\n  }\n\n  return a.trim();\n}\n\n;\n\nfunction computeNormal(facet) {\n  var v = facet.verts;\n  return normalize(v[0][0], v[0][1], v[0][2], v[1][0], v[1][1], v[1][2], v[2][0], v[2][1], v[2][2]);\n}\n\nfunction exp(a) {\n  return a.toExponential();\n}\n\nmodule.exports = {\n  facetNormal: computeNormal,\n  // `stl` may be binary or ascii\n  toObject: function toObject(stl) {\n    var ret = {\n      description: '',\n      facets: []\n    };\n    var s = this.createParseStream();\n    s.on('data', function (d) {\n      if (!d.verts) {\n        if (!ret.description) {\n          ret.description = d.description;\n        }\n      } else {\n        ret.facets.push(d);\n      }\n    });\n    s.write(!Buffer.isBuffer(stl) ? new Buffer(stl) : stl);\n    s.end();\n    return ret;\n  },\n  // Convert the incoming object into the stl\n  // file format. Passing a truthy value for\n  // binary causes a binary stl to be created.\n  fromObject: function fromObject(obj, binary) {\n    if (!binary) {\n      var str = ['solid ' + obj.description.trim()];\n      var fl = obj.facets.length;\n\n      for (var j = 0; j < fl; j++) {\n        var facet = obj.facets[j];\n        var n = facet.normal || computeNormal(facet);\n        str.push('  facet normal ' + [exp(n[0]), exp(n[1]), exp(n[2])].join(' '));\n        str.push('    outer loop');\n        var v = facet.verts;\n        var p = '      vertex ';\n        str.push(p + [exp(v[0][0]), exp(v[0][1]), exp(v[0][2])].join(' '));\n        str.push(p + [exp(v[1][0]), exp(v[1][1]), exp(v[1][2])].join(' '));\n        str.push(p + [exp(v[2][0]), exp(v[2][1]), exp(v[2][2])].join(' '));\n        str.push('    endloop');\n        str.push('  endfacet');\n      }\n\n      str.push('endsolid');\n      return str.join('\\n');\n    } else {\n      var count = obj.facets.length;\n      var ret = new Buffer(84 + count * 12 * 4 + count * 2);\n      ret.fill(0, 0, 80);\n      ret.write(obj.description || '');\n      ret.writeUInt32LE(count, 80);\n      var offset = 84;\n\n      var write = function write(val) {\n        ret.writeFloatLE(val, offset);\n        offset += 4;\n      };\n\n      var facetCount = obj.facets.length;\n\n      for (var j = 0; j < facetCount; j++) {\n        var facet = obj.facets[j];\n        var n = facet.normal || computeNormal(facet);\n        write(n[0]);\n        write(n[1]);\n        write(n[2]);\n        var l = facet.verts.length;\n\n        for (var i = 0; i < l; i++) {\n          var vert = facet.verts[i];\n          write(vert[0]);\n          write(vert[1]);\n          write(vert[2]);\n        }\n\n        ret.writeUInt16LE(facet.attributeByteCount || 0, offset);\n        offset += 2;\n      }\n\n      return ret;\n    }\n  },\n  createParseStream: function createParseStream() {\n    var binaryMode = false;\n    var facetCount = 0;\n    var facets = [];\n    var description = null;\n    var currentFacet;\n    var asciiValid = false;\n    var ended = false;\n    var splitter = null;\n    var stream = fsm({\n      init: fsm.want(84, function readBinaryHeader(data) {\n        var dataString = data.toString();\n\n        if (dataString.toLowerCase().indexOf('solid') > -1) {\n          facetCount = data.readUInt32LE(80);\n          this.change('ascii');\n        } else {\n          this.change('binary');\n        }\n\n        return 0;\n      }),\n      binary: fsm.want(80, function (data) {\n        description = trim(data.toString());\n        this.change('count');\n      }),\n      count: fsm.want(4, function (data) {\n        facetCount = data.readUInt32LE(0);\n        this.queue({\n          description: description,\n          facetCount: facetCount\n        });\n        this.change('normal');\n      }),\n      normal: fsm.want(12, function (data) {\n        currentFacet = {\n          normal: [data.readFloatLE(0), data.readFloatLE(4), data.readFloatLE(8)],\n          verts: []\n        };\n        this.change('verts');\n      }),\n      verts: fsm.want(36, function (data) {\n        for (var i = 0; i < 36; i += 12) {\n          currentFacet.verts.push([data.readFloatLE(i), data.readFloatLE(i + 4), data.readFloatLE(i + 8)]);\n        }\n\n        this.change('attributeBytes');\n      }),\n      attributeBytes: fsm.want(2, function (data) {\n        currentFacet.attributeByteCount = data.readUInt16LE(0);\n        this.queue(currentFacet);\n        currentFacet = null;\n        facetCount--;\n\n        if (facetCount <= 0) {\n          this.done();\n        } else {\n          this.change('normal');\n        }\n      }),\n      ascii: function ascii(pending) {\n        if (!splitter) {\n          splitter = split();\n          stream.on('end', function () {\n            splitter.end();\n          });\n          var inFacet = false;\n          var facet;\n          var that = this;\n          splitter.on('data', function (data) {\n            if (!data.trim().length) {\n              return;\n            }\n\n            if (data.indexOf('solid') > -1) {\n              stream.queue({\n                description: data.trim().split(' ').slice(1).join(' ')\n              });\n            } else if (data.indexOf('endfacet') > -1) {\n              if (!facet.normal.length) {// facet.normal = computeNormal(facet);\n              }\n\n              inFacet = false;\n              stream.queue(facet);\n              facet = null;\n            } else if (data.indexOf('facet') > -1) {\n              // This is not fool proof, but far better than\n              // \"OH LOOK I NAMED MY STL 'solid'\" *sigh*\n              asciiValid = true;\n              var normal = data.replace(/ +/g, ' ').trim().split(' ').slice(2).map(parseFloat);\n              facet = {\n                normal: normal,\n                verts: [],\n                attributeByteCount: 0\n              };\n            } else if (data.indexOf('vertex') > -1) {\n              var coords = data.replace(/ +/g, ' ').trim().split(' ').slice(1).map(parseFloat);\n              facet.verts.push(coords);\n            } else if (!asciiValid) {\n              that.mode('binary');\n            }\n          });\n          stream.originalWrite = stream.write;\n        }\n\n        splitter.write(pending);\n        ended && stream.end(); // Returning false here buffers the data.\n        // If we are not \"sure\" this is an ascii stl file then\n        // we need to continue buffering\n\n        return asciiValid ? pending.length : false;\n      }\n    }, function () {});\n    stream.originalEnd = stream.end;\n\n    stream.end = function (d) {\n      var mode = stream.fsm.mode();\n      var cache = stream.fsm.cache();\n\n      if (mode === 'ascii' && !asciiValid && cache) {\n        // this is a binary file that has the description: \"solid ...\"\n        // send the complete file through binary mode\n        stream.fsm.change('binary'); // trigger a write since we have the entire file buffered in memory\n\n        stream.fsm();\n        stream.originalEnd();\n      } else {\n        ended = true;\n        stream.originalEnd();\n      }\n    };\n\n    return stream;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}